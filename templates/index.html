<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EchoSplit</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <div class="container">
    <img id="logo" src="{{ url_for('static', filename='logo.png') }}" alt="EchoSplit" />

    <!-- 1. Upload Section -->
    <div id="stage-upload">
      <h1>ðŸŽ§ EchoSplit</h1>

      <form id="upload-form">
        <input type="file" name="file" required />
        <button type="submit">Upload & Separate</button>
      </form>

      <p id="limit-msg" class="hidden">
        ðŸš« You've used your 2 free splits.<br />
        Enter a key or <a href="https://yourshopifykeypage.com" target="_blank">Buy a Key</a>
      </p>

      <form id="key-form" class="hidden">
        <input type="text" name="key" placeholder="Enter your key" required />
        <button type="submit">Submit Key</button>
      </form>
    </div>

    <!-- 2. Processing Stage -->
    <div id="stage-processing" class="hidden">
      <div class="loader"></div>
      <h2><strong>Processingâ€¦</strong></h2>
      <p>May take 1â€“2 minutes depending on file size</p>
    </div>

    <!-- 3. Results -->
    <div id="stage-results" class="hidden">
      <h2>ðŸŽ¶ Separated Stems</h2>
      <ul id="stem-list"></ul>
    </div>
  </div>

  <script>
    const uploadForm = document.getElementById('upload-form');
    const keyForm = document.getElementById('key-form');
    const stageUpload = document.getElementById('stage-upload');
    const stageProcessing = document.getElementById('stage-processing');
    const stageResults = document.getElementById('stage-results');
    const limitMsg = document.getElementById('limit-msg');
    const stemList = document.getElementById('stem-list');
    const bucket = "{{ bucket_name }}";

    uploadForm.addEventListener('submit', e => {
      e.preventDefault();
      stageUpload.classList.add('hidden');
      stageProcessing.classList.remove('hidden');

      const file = uploadForm.querySelector('input[name="file"]').files[0];
      const formData = new FormData();
      formData.append('file', file);

      fetch('/', { method: 'POST', body: formData })
        .then(res => {
          if (!res.ok) throw new Error('Upload failed');
          return res.json();
        })
        .then(json => {
          if (json.blocked) {
            stageProcessing.classList.add('hidden');
            stageUpload.classList.remove('hidden');
            limitMsg.classList.remove('hidden');
            keyForm.classList.remove('hidden');
          } else {
            pollResults(file.name);
          }
        })
        .catch(err => {
          alert(err.message);
          stageProcessing.classList.add('hidden');
          stageUpload.classList.remove('hidden');
        });
    });

    keyForm.addEventListener('submit', e => {
      e.preventDefault();
      const key = keyForm.querySelector('input[name="key"]').value;
      fetch('/use_key', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ key: key })
      }).then(res => {
        if (res.ok) {
          alert('Key accepted. You may now upload again.');
          limitMsg.classList.add('hidden');
          keyForm.classList.add('hidden');
        } else {
          alert('Invalid key.');
        }
      });
    });

    function pollResults(filename) {
      const base = filename.replace(/\.[^/.]+$/, '');
      let attempts = 0;
      const maxAttempts = 30;

      const interval = setInterval(() => {
        attempts++;
        fetch(`/status?filename=${encodeURIComponent(filename)}`)
          .then(res => res.json())
          .then(json => {
            if (json.done) {
              clearInterval(interval);
              showResults(json.urls);
            } else if (attempts >= maxAttempts) {
              clearInterval(interval);
              alert('Still processingâ€”please refresh in a moment.');
              stageProcessing.classList.add('hidden');
              stageUpload.classList.remove('hidden');
            }
          })
          .catch(() => {
            if (attempts >= maxAttempts) {
              clearInterval(interval);
              alert('Error checking status.');
              stageProcessing.classList.add('hidden');
              stageUpload.classList.remove('hidden');
            }
          });
      }, 4000);
    }

function showResults(urls) {
  ['vocals', 'drums', 'bass', 'other'].forEach(stem => {
    const li = document.createElement('li');
    const a = document.createElement('a');
    a.href = urls[stem];
    a.textContent = stem.charAt(0).toUpperCase() + stem.slice(1);
    a.download = ''; // ðŸ”½ THIS ensures it downloads
    li.appendChild(a);
    stemList.appendChild(li);
  });
  stageProcessing.classList.add('hidden');
  stageResults.classList.remove('hidden');
}